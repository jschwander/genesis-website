import { Args, Flags } from '@oclif/core';
import chalk from 'chalk';
import inquirer from 'inquirer';
import ora from 'ora';
import { deleteLogs as deleteLogsAction, logs as getLogsAction, } from '../../actions/functions/logs.js';
import { DeployedBlueprintCommand } from '../../baseCommands.js';
import { formatTitle } from '../../utils/display/blueprints-formatting.js';
import { findFunctionByName } from '../../utils/find-function.js';
function logLevel(level) {
    if (level === 'ERROR') {
        return chalk.red(level);
    }
    if (level === 'WARN') {
        return chalk.yellow(level);
    }
    return chalk.green(level);
}
export default class LogsCommand extends DeployedBlueprintCommand {
    static args = {
        name: Args.string({ description: 'The name of the Sanity Function', required: true }),
    };
    static description = 'Retrieve or delete logs for a Sanity Function';
    static examples = [
        '<%= config.bin %> <%= command.id %> <name>',
        '<%= config.bin %> <%= command.id %> <name> --json',
        '<%= config.bin %> <%= command.id %> <name> --limit 100',
        '<%= config.bin %> <%= command.id %> <name> --delete',
    ];
    static flags = {
        limit: Flags.integer({
            char: 'l',
            description: 'Total number of log entries to retrieve',
            required: false,
            default: 50,
        }),
        json: Flags.boolean({
            char: 'j',
            description: 'Return logs in JSON format',
            required: false,
        }),
        utc: Flags.boolean({
            char: 'u',
            description: 'Show dates in UTC time zone',
            required: false,
        }),
        delete: Flags.boolean({
            char: 'd',
            exclusive: ['limit', 'json'],
            description: 'Delete all logs for the function',
            required: false,
        }),
        force: Flags.boolean({
            char: 'f',
            dependsOn: ['delete'],
            description: 'Skip confirmation for deleting logs',
            required: false,
        }),
    };
    externalId;
    async run() {
        const args = this.args;
        const flags = this.flags;
        const { externalId } = findFunctionByName(this.deployedStack, args.name);
        this.externalId = externalId;
        if (flags.delete === true) {
            await this.runDeleteLogs(args.name, flags);
        }
        else {
            await this.runGetLogs(args.name, flags);
        }
    }
    async runDeleteLogs(name, options) {
        if (!this.externalId)
            this.error('Unable to delete logs. Unable to determine function ID.');
        if (!options.force) {
            const { certain } = await inquirer.prompt({
                type: 'confirm',
                name: 'certain',
                message: `Are you sure you want to delete ${chalk.bold('all')} logs for function ${chalk.yellow(name)}?`,
                default: false,
            });
            if (!certain)
                return;
        }
        const spinner = ora(`Deleting logs for function ${chalk.yellow(name)}`).start();
        const { ok, error } = await deleteLogsAction(this.externalId, this.auth);
        if (!ok) {
            spinner.fail(`${chalk.red('Failed')} to retrieve logs`);
            this.log(`Error: ${error || 'Unknown error'}`);
            return;
        }
        spinner.succeed('Logs deleted');
    }
    async runGetLogs(name, options) {
        if (!this.externalId)
            this.error('Unable to retrieve logs. Unable to determine function ID.');
        const spinner = ora(`Finding logs for function "${name}"`).start();
        const { ok, error, logs, total } = await getLogsAction(this.externalId, { limit: options.limit }, this.auth);
        if (!ok) {
            spinner.fail(`${chalk.red('Failed')} to retrieve logs`);
            this.log(`Error: ${error || 'Unknown error'}`);
            return;
        }
        const filteredLogs = logs.filter((entry) => entry.level && entry.message);
        if (filteredLogs.length === 0) {
            spinner.info(`No logs found for function ${name}`);
            return;
        }
        spinner.succeed(`${formatTitle('Function', name)} Logs`);
        if (!options.json) {
            this.log(`Found ${chalk.bold(total)} log entries for function ${chalk.yellow(name)}`);
            if (logs.length < total) {
                this.log(`Here are the last ${chalk.bold(filteredLogs.length.toString())} entries`);
            }
            this.log('\n');
            for (const log of filteredLogs) {
                const { time, level, message } = log;
                const date = new Date(time);
                const [dateString, timeString] = options.utc
                    ? date.toISOString().slice(0, 19).split('T')
                    : [date.toLocaleDateString(), date.toLocaleTimeString()];
                this.log([chalk.bold(dateString), chalk.bold.blue(timeString), logLevel(level), message].join(' '));
            }
        }
        else {
            this.log(JSON.stringify(filteredLogs, null, 2));
        }
    }
}
