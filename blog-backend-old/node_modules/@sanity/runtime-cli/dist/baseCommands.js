// * https://oclif.io/docs/base_class
import { Command } from '@oclif/core';
import { readLocalBlueprint } from './actions/blueprints/blueprint.js';
import { getStack } from './actions/blueprints/stacks.js';
import { presentBlueprintParserErrors } from './utils/display/errors.js';
import { niceId } from './utils/display/presenters.js';
import { validTokenOrErrorMessage } from './utils/validated-token.js';
/**
 * @description Guarantees flags, args, sanityToken, and blueprint.
 * Blueprint parser errors are logged and the command exits with an error
 * @extends Command
 */
export class BlueprintCommand extends Command {
    sanityToken;
    blueprint;
    flags;
    args;
    async init() {
        const { args, flags } = await this.parse({
            flags: this.ctor.flags,
            baseFlags: super.ctor.baseFlags,
            enableJsonFlag: this.ctor.enableJsonFlag,
            args: this.ctor.args,
            strict: this.ctor.strict,
        });
        this.flags = flags;
        this.args = args;
        await super.init();
        const { token, error: tokenErr } = await validTokenOrErrorMessage();
        if (tokenErr)
            this.error(tokenErr.message);
        this.sanityToken = token;
        const blueprint = await readLocalBlueprint();
        if (blueprint.errors.length > 0) {
            this.log(presentBlueprintParserErrors(blueprint.errors));
            this.error('Unable to parse Blueprint file.');
        }
        this.blueprint = blueprint;
    }
    async catch(err) {
        // add any custom logic to handle errors from the command
        // or simply return the parent class error handling
        return super.catch(err);
    }
    async finally(_) {
        // called after run and catch regardless of whether or not the command errored
        return super.finally(_);
    }
}
/**
 * @description Guarantees flags, args, sanityToken, blueprint, projectId, stackId, auth, and deployedStack.
 * If a project or stack is missing, the command exits with an error
 * @extends BlueprintCommand
 */
export class DeployedBlueprintCommand extends BlueprintCommand {
    auth;
    deployedStack;
    projectId;
    stackId;
    async init() {
        await super.init();
        const { projectId, stackId } = this.blueprint;
        if (!(projectId && stackId)) {
            this.log(`Run \`${this.config.bin} blueprints config --edit --test\` to update your config`);
            if (!projectId)
                this.error('Missing Project configuration for Blueprint');
            if (!stackId)
                this.error('Missing deployment configuration for Blueprint');
        }
        this.projectId = projectId;
        this.stackId = stackId;
        this.auth = { token: this.sanityToken, projectId };
        const stackResponse = await getStack({ stackId, auth: this.auth });
        if (!stackResponse.ok) {
            this.log(`Could not retrieve deployment info for ${niceId(stackId)}. Was it destroyed?`);
            this.log(`Run \`${this.config.bin} blueprints config --edit --test\` to update your config`);
            this.error('Missing deployment');
        }
        this.deployedStack = stackResponse.stack;
    }
}
