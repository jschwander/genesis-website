import { setTimeout } from 'node:timers/promises';
import chalk from 'chalk';
import ora from 'ora';
import { stashAsset } from '../../actions/blueprints/assets.js';
import { getStack, updateStack } from '../../actions/blueprints/stacks.js';
import { niceId } from '../../utils/display/presenters.js';
import { isLocalFunctionResource } from '../../utils/types.js';
export async function blueprintDeployCore(options) {
    const { bin = 'sanity', log, auth, stackId, projectId, deployedStack, blueprint, flags } = options;
    const noWait = flags['no-wait'] || false;
    try {
        const { resources } = blueprint.parsedBlueprint;
        const validResources = resources?.filter((r) => r.type);
        const functionResources = validResources?.filter(isLocalFunctionResource);
        // First stash all function assets
        if (functionResources?.length) {
            for (const resource of functionResources) {
                const fnSpinner = ora(`Processing ${resource.name}...`).start();
                const result = await stashAsset({ resource, auth });
                if (result.success && result.assetId) {
                    const src = resource.src;
                    resource.src = result.assetId; // TODO: properly reference asset - for now, the API expects the assetId
                    fnSpinner.succeed(`${resource.name} ${niceId(result.assetId)}`);
                    log(`   Source: ${src}`);
                }
                else {
                    fnSpinner.fail(`Failed to process ${resource.name}`);
                    log(`   Error: ${result.error}`);
                    return { success: false, error: result.error || 'Failed to process function resource' };
                }
            }
        }
        const stackPayload = {
            projectId,
            name: deployedStack.name,
            document: { resources: validResources },
        };
        const spinner = ora('Deploying...').start();
        const { ok: deployOk, stack, error: deployError, } = await updateStack({ stackId, stackPayload, auth });
        if (deployOk) {
            spinner.succeed(`Deployment "${chalk.bold(stack.name)}" ${niceId(stack.id)} started!`);
            if (!noWait) {
                const waitSpinner = ora('Waiting for deployment to complete...').start();
                while (true) {
                    // TODO: watch logs and print those while polling
                    const { ok, stack: currentStack } = await getStack({ stackId: stack.id, auth });
                    if (!ok) {
                        waitSpinner.fail('Failed to check deployment status');
                        return { success: false, error: 'Failed to check deployment status' };
                    }
                    const operation = currentStack.recentOperation;
                    if (!operation) {
                        waitSpinner.fail('No operation found');
                        return { success: false, error: 'No operation found' };
                    }
                    if (operation.status === 'COMPLETED') {
                        waitSpinner.succeed('Deployment completed successfully');
                        break;
                    }
                    if (operation.status === 'FAILED') {
                        waitSpinner.fail('Deployment failed');
                        return { success: false, error: 'Deployment failed' };
                    }
                    await setTimeout(1000);
                }
            }
            else {
                log(`Use \`${bin} blueprints info\` to check status`);
            }
            return { success: true };
        }
        spinner.fail(`${chalk.red('Failed')} to update deployment`);
        log(`Error: ${deployError || JSON.stringify(stack, null, 2) || 'Unknown error'}`);
        return { success: false, error: deployError || 'Failed to update deployment' };
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log(`Error: ${errorMessage}`);
        return { success: false, error: errorMessage };
    }
}
