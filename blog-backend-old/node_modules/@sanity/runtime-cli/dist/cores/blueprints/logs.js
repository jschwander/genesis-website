import chalk from 'chalk';
import ora from 'ora';
import { findNewestLogTimestamp, getLogs, getRecentLogs, isNewerLog, streamLogs, } from '../../actions/blueprints/logs.js';
import { formatTitle } from '../../utils/display/blueprints-formatting.js';
import { formatLogEntry, formatLogsByDay, organizeLogsByDay, } from '../../utils/display/logs-formatting.js';
import { niceId } from '../../utils/display/presenters.js';
export async function blueprintLogsCore(options) {
    const { log, auth, stackId, deployedStack, flags } = options;
    const { watch = false } = flags;
    const spinner = ora(`Fetching recent logs for deployment ${niceId(stackId)}`).start();
    try {
        if (watch) {
            const { ok, logs, error } = await getLogs(stackId, auth);
            if (!ok) {
                spinner.fail(`${chalk.red('Failed')} to retrieve logs`);
                log(`Error: ${error || 'Unknown error'}`);
                return { success: false, error: error || 'Failed to retrieve logs' };
            }
            spinner.stop();
            log(`${formatTitle('Blueprint', deployedStack.name)} ${niceId(stackId)} logs`);
            if (logs.length > 0) {
                log('\nMost recent logs:');
                const recentLogs = getRecentLogs(logs);
                for (const logEntry of recentLogs) {
                    log(`  ${formatLogEntry(logEntry)}`);
                }
            }
            else {
                log(`No recent logs found for deployment ${niceId(stackId)}`);
            }
            const onOpen = () => {
                log(`Watching for new logs... ${chalk.bold('ctrl+c')} to stop`);
            };
            let newestTimestamp = findNewestLogTimestamp(logs);
            const renderLog = (logEntry) => {
                if (!isNewerLog(logEntry, newestTimestamp))
                    return;
                newestTimestamp = new Date(logEntry.timestamp).getTime();
                log(formatLogEntry(logEntry, true));
            };
            streamLogs(stackId, auth, renderLog, onOpen, (error) => log(`${chalk.red('Error:')} ${error}`));
            // Return a special key for streaming mode
            return {
                success: true,
                streaming: new Promise(() => { }),
            };
        }
        // Regular non-streaming logs
        const { ok, logs, error } = await getLogs(stackId, auth);
        if (!ok) {
            spinner.fail(`${chalk.red('Failed')} to retrieve logs`);
            log(`Error: ${error || 'Unknown error'}`);
            return { success: false, error: error || 'Failed to retrieve logs' };
        }
        if (logs.length === 0) {
            spinner.info(`No logs found for deployment ${stackId}`);
            return { success: true };
        }
        spinner.succeed(`${formatTitle('Blueprint', deployedStack.name)} Logs`);
        log(`Found ${chalk.bold(logs.length.toString())} log entries for deployment ${niceId(stackId)}\n`);
        // Organize and format logs by day
        const logsByDay = organizeLogsByDay(logs);
        log(formatLogsByDay(logsByDay));
        return { success: true };
    }
    catch (err) {
        spinner.fail('Failed to retrieve logs');
        const errorMessage = err instanceof Error ? err.message : String(err);
        log(`Error: ${errorMessage}`);
        return { success: false, error: errorMessage };
    }
}
