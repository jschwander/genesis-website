import { setTimeout } from 'node:timers/promises';
import chalk from 'chalk';
import inquirer from 'inquirer';
import ora from 'ora';
import { destroyStack, getStack } from '../../actions/blueprints/stacks.js';
import { niceId } from '../../utils/display/presenters.js';
export async function blueprintDestroyCore(options) {
    const { bin = 'sanity', log, token, blueprint, flags } = options;
    const { force = false, 'project-id': flagProjectId, 'stack-id': flagStackId, 'no-wait': noWait = false, } = flags;
    // 3-flag combo: just destroy it
    if (flagProjectId && flagStackId && force) {
        const { ok, error, stack } = await destroyStack({
            stackId: flagStackId,
            auth: { token, projectId: flagProjectId },
        });
        if (!ok)
            return { success: false, error: error || 'Failed to destroy deployment' };
        log(`Deployment "${stack.name}" ${niceId(stack.id)} destroyed`);
        return { success: true };
    }
    const { projectId, stackId } = blueprint;
    if (!projectId)
        return { success: false, error: 'Project ID is required' };
    const auth = { token, projectId };
    let stack;
    try {
        if (flagStackId) {
            const flagStack = await getStack({ stackId: flagStackId, auth });
            if (!flagStack.ok)
                return { success: false, error: flagStack.error || 'Failed to get stack' };
            stack = flagStack.stack;
        }
        else if (stackId) {
            const blueprintStack = await getStack({ stackId, auth });
            if (!blueprintStack.ok)
                return { success: false, error: blueprintStack.error || 'Failed to get stack' };
            stack = blueprintStack.stack;
        }
        if (!stack)
            return { success: false, error: 'Deployment not found' };
        const destroySpinner = ora({
            text: `Destroying ${chalk.bold(stack.name)} ${niceId(stack.id)}...`,
            color: 'red',
        });
        if (!force) {
            const { confirm } = await inquirer.prompt([
                {
                    type: 'confirm',
                    name: 'confirm',
                    message: `Are you sure you want to destroy stack "${stack.name}" ${niceId(stack.id)}?`,
                    default: false,
                },
            ]);
            if (!confirm) {
                log('Deployment destruction cancelled');
                return { success: true };
            }
            destroySpinner.start();
            // 5 second countdown
            let i = 5;
            while (i >= 0) {
                destroySpinner.text = `Destroying deployment in ${chalk.bold((i--).toString())} seconds...`;
                await setTimeout(1000);
            }
            destroySpinner.text = 'Destroying deployment ðŸ’¥';
            await setTimeout(500);
        }
        else {
            destroySpinner.start();
        }
        const { ok, error } = await destroyStack({ stackId: stack.id, auth });
        if (!ok) {
            destroySpinner.fail('Failed to destroy deployment');
            return { success: false, error: error || 'Failed to destroy deployment' };
        }
        if (noWait) {
            destroySpinner.succeed(`Deployment "${stack.name}" ${niceId(stack.id)} destroy started!`);
            log(`Use \`${bin} blueprints info\` to check status`);
            return { success: true };
        }
        destroySpinner.stop();
        const waitSpinner = ora('Waiting for destruction to complete...').start();
        while (true) {
            const { ok: pollOk, stack: currentStack } = await getStack({ stackId: stack.id, auth });
            const operation = currentStack?.recentOperation;
            if (!pollOk || !operation || operation?.status === 'COMPLETED') {
                // Operation is also marked destroyed when stack is deleted
                // It's possible that the operation is "gone" or available and "COMPLETED"
                waitSpinner.succeed(`Deployment "${stack.name}" ${niceId(stack.id)} destroyed`);
                break;
            }
            if (operation.status === 'FAILED') {
                waitSpinner.fail('Destruction failed');
                log(`Run \`${bin} blueprints logs\` for more details`);
                return { success: false, error: 'Destruction failed' };
            }
            await setTimeout(1000);
        }
        return { success: true };
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log(`Error: ${errorMessage}`);
        return { success: false, error: errorMessage };
    }
}
