import { spawn } from 'node:child_process';
import { performance } from 'node:perf_hooks';
import { cwd } from 'node:process';
import { setTimeout } from 'node:timers';
import config from '../config.js';
import { bundleFunction } from './bundle/bundle-function.js';
import { findFunctionEntryPoint } from './functions/find-entry-point.js';
import { shouldBundleFunction } from './functions/should-bundle.js';
function getChildProcessWrapperPath() {
    return new URL('./child-process-wrapper.js', import.meta.url).pathname;
}
export function sanitizeLogs(logs) {
    return logs.replace(/([a-zA-Z0-9]{10})[a-zA-Z0-9]{65,}/g, '$1**********');
}
export default async function invoke(resource, data, context, timeout = 5) {
    if (!resource.src) {
        throw new Error(`Function resource "${resource.name}" is missing the 'src' property.`);
    }
    let cleanupBundle = async () => { };
    let functionPath = '';
    let bundleTimings = undefined;
    if (await shouldBundleFunction(resource)) {
        const bundleResult = await bundleFunction(resource);
        functionPath = await findFunctionEntryPoint(bundleResult.outputDir);
        bundleTimings = bundleResult.timings;
        cleanupBundle = bundleResult.cleanup;
    }
    else {
        functionPath = await findFunctionEntryPoint(resource.src, resource.displayName ?? resource.name);
    }
    return new Promise((resolve, reject) => {
        let child;
        let timer;
        let executionStart;
        function start() {
            executionStart = performance.now();
            child = spawn('node', ['--enable-source-maps', getChildProcessWrapperPath()], {
                cwd: cwd(),
                stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
            });
            child.on('message', (data) => {
                const executionTimeMs = performance.now() - executionStart;
                const { json, logs } = JSON.parse(data.toString());
                shutdown();
                resolve({
                    json,
                    logs: sanitizeLogs(logs),
                    error: undefined,
                    timings: {
                        ...bundleTimings,
                        execute: executionTimeMs,
                    },
                });
            });
            child.on('error', (error) => {
                shutdown();
                reject(new Error(`encountered error ${error.message}`));
            });
            child.on('exit', (code) => {
                const executionTimeMs = performance.now() - executionStart;
                shutdown();
                if (code !== 0) {
                    reject(new Error(`exited with code ${code}`));
                }
                else {
                    resolve({
                        json: {},
                        logs: '',
                        error: undefined,
                        timings: {
                            ...bundleTimings,
                            execute: executionTimeMs,
                        },
                    });
                }
            });
            timer = setTimeout(() => {
                shutdown();
                reject(new Error(`Timed out after hitting its ${timeout}s timeout!`));
            }, timeout * 1000);
            const payload = {
                ...data,
                context: {
                    ...context,
                    clientOptions: {
                        ...context.clientOptions,
                        apiHost: config.apiUrl,
                        token: config.token,
                    },
                },
            };
            child.send(JSON.stringify({ srcPath: functionPath, payload }, null, 2));
        }
        function shutdown() {
            clearTimeout(timer);
            if (child && !child.killed) {
                child.kill();
            }
            cleanupBundle().catch((err) => console.warn('Bundle cleanup failed:', err));
        }
        start();
    });
}
